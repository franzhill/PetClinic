{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"WELCOME","text":""},{"location":"json_simple_fixtures/","title":"Fixture Loading Mechanism for Integration Tests","text":"<p>The fixture framework I am currently working on aims at providing a structured and flexible  mechanism for loading test fixtures into the database during (before) integration  tests.</p> <p>I started off with one strategy, then tried out another one. So there are two distinct possible strategies. - SpringFixtureLoader - JUnitFixtureLoader</p> <p> </p>"},{"location":"json_simple_fixtures/#1-spring-transactional-fixture-loading-recommended","title":"&gt; 1. Spring Transactional Fixture Loading (Recommended)","text":""},{"location":"json_simple_fixtures/#summary","title":"&gt;&gt; Summary","text":"<p>Fixtures are loaded inside the Spring context and within the test transaction, so that:</p> <ul> <li>They are rolled back after each test</li> <li>No manual purge is needed</li> <li>Test classes remain clean and isolated</li> </ul>"},{"location":"json_simple_fixtures/#how-to-use","title":"&gt;&gt; How to use","text":"<p>A meta annotation was created to encapsulate other annotations and simplify things:</p> <pre><code>@MetaSpringBootTestWithJsonSimpleFixtures\n@Fixtures({ Owner.class, Pet.class })\nclass MyIntegrationTest {\n    // Each test runs with fresh data and leaves no residue.\n}\n</code></pre> <p>Alternatively, if you prefer not to use the meta-annotation, the important annotations are:</p> <pre><code>@SpringBootTest\n@Transactional\n@TestExecutionListeners(\n    value = FixtureTestExecutionListener.class,\n    mergeMode = TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS\n)\n@Fixtures({ Owner.class, Pet.class })\nclass MyIntegrationTest { ... }\n</code></pre>"},{"location":"json_simple_fixtures/#loading-lifecycle","title":"&gt;&gt; Loading lifecycle","text":"<p>Optional control is given on when the fixtures are loaded with <code>Fixtures.Lifecycle</code> (<code>PER_METHOD</code> or <code>PER_CLASS</code>)   The default  is <code>PER_METHOD</code>.  </p> <p>Example:</p> <pre><code>@Fixtures(value = { Owner.class, Pet.class }, lifecycle = Fixtures.Lifecycle.PER_CLASS)\n</code></pre>"},{"location":"json_simple_fixtures/#how-it-works","title":"&gt;&gt; How It Works","text":"<ul> <li>A \"fixture loading\" execution listener (aka \"fixture loader\") is registered as a Spring <code>TestExecutionListener</code>.  </li> <li>Spring\u2019s testing framework wraps each test method in a transaction when <code>@Transactional</code> is present.  </li> <li>The fixture loader hooks into the Spring test lifecycle (right after the <code>ApplicationContext</code> is prepared, before the test method executes).  </li> <li>At that point, it:</li> <li>Opens the test transaction.  </li> <li>Loads the requested fixture files/entities into the database.  </li> <li>Hands control back to the test.  </li> <li>When the test finishes, Spring rolls back the transaction automatically \u2192 all inserted fixtures vanish, leaving the DB clean.  </li> </ul> <p>\ud83d\udc49 This is why you never need a purge step: Spring guarantees full rollback isolation.</p> <p></p>"},{"location":"json_simple_fixtures/#caveats-with-the-spring-transactional-strategy","title":"&gt;&gt; Caveats with the Spring Transactional Strategy","text":"<p>When the code under test starts/participates in its own transactions, results may differ from the simple \u201ceverything rolls back\u201d mental model. Key cases:</p>"},{"location":"json_simple_fixtures/#1-default-propagation-required-joins-the-test-transaction","title":"1) Default propagation (<code>REQUIRED</code>) \u2014 joins the test transaction \u2705","text":"<ul> <li>Most <code>@Transactional</code> methods use <code>Propagation.REQUIRED</code> (the default).  </li> <li>They join the test method\u2019s transaction, so all writes are rolled back at the end of the test.  </li> <li>Implication: You cannot observe a real commit inside the same test transaction. If you need to assert post\u2011commit effects (e.g., visibility to another thread/connection), you must end the test transaction first (see below).</li> </ul>"},{"location":"json_simple_fixtures/#2-requires_new-or-manual-transactiontemplate-commits-despite-outer-rollback","title":"2) <code>REQUIRES_NEW</code> or manual <code>TransactionTemplate</code> \u2014 commits despite outer rollback \u26a0\ufe0f","text":"<ul> <li>Methods using <code>Propagation.REQUIRES_NEW</code> or an explicit <code>TransactionTemplate</code> start a separate transaction that commits independently.  </li> <li>Even if the test method is rolled back, the inner <code>REQUIRES_NEW</code> work may persist \u2192 dirty DB after test.</li> <li>Mitigations (pick what fits best):</li> <li>Prefer REQUIRED in tests: Provide a test\u2011only bean/config that downgrades <code>REQUIRES_NEW</code> to <code>REQUIRED</code> for the code path under test (profile-based or conditional AOP).  </li> <li>Explicit cleanup: Use a targeted cleanup in <code>@AfterEach</code> (truncate affected tables) or <code>@Sql(executionPhase = AFTER_TEST_METHOD, scripts = \"...\")</code>.  </li> <li> <p>Transactional choreography with <code>TestTransaction</code>:     ```java     // End the test transaction before invoking the code that must really commit:     if (TestTransaction.isActive()) {         // We typically want isolation; rollback current fixtures to avoid cross-talk         TestTransaction.flagForRollback();         TestTransaction.end();     }</p> <p>// Now invoke service method that uses REQUIRES_NEW or real commits service.performCriticalCommit();</p> <p>// Optionally start a fresh test transaction for assertions/cleanup TestTransaction.start(); // assert DB state, then rely on rollback at test end ```   - Fallback: For a small subset of scenarios, use the JUnit (non-transactional) strategy + explicit purge to mirror production commit behavior.</p> </li> </ul>"},{"location":"json_simple_fixtures/#3-nested-propagation-savepoints-if-supported","title":"3) <code>NESTED</code> propagation \u2014 savepoints (if supported) \u2705","text":"<ul> <li>With <code>Propagation.NESTED</code>, Spring uses savepoints (driver dependent).  </li> <li>An outer rollback rolls back nested work as well \u2192 typically safe in tests.</li> </ul>"},{"location":"json_simple_fixtures/#4-async-different-threads-no-participation-in-test-tx","title":"4) Async / different threads \u2014 no participation in test TX \u26a0\ufe0f","text":"<ul> <li>Work run via <code>@Async</code>, scheduler threads, or separate executors does not join the test transaction by default.  </li> <li>Such work may commit independently and persist. Consider disabling async in tests, using synchronous executors, or providing explicit cleanup.</li> </ul>"},{"location":"json_simple_fixtures/#5-read-only-transactions","title":"5) Read-only transactions \ud83d\udec8","text":"<ul> <li>If the test (or code under test) uses <code>@Transactional(readOnly = true)</code>, some providers may optimize away writes or throw exceptions. Ensure write paths are not annotated read-only in tests that insert fixtures.</li> </ul> <p>Rule of thumb: - If everything uses <code>REQUIRED</code>, the Spring strategy provides perfect isolation. - If any path uses <code>REQUIRES_NEW</code> / async / manual transactions, add one of the mitigations above to avoid residue or false assertions.</p> <p> </p>"},{"location":"json_simple_fixtures/#2-junit-fixture-loading-first-strategy-i-developped","title":"&gt; 2. JUnit Fixture Loading (first strategy I developped)","text":""},{"location":"json_simple_fixtures/#summary_1","title":"&gt;&gt; Summary","text":"<p>Fixtures are loaded using a JUnit 5 extension that hooks into <code>@BeforeEach</code> or <code>@BeforeAll</code>. This is the first strategy that I developed, however it does not natively support \"purging\" the DB after each test. This can be done, but I haven't got round to it, since the Spring  transactional strategy seemed better.</p>"},{"location":"json_simple_fixtures/#how-to-use_1","title":"&gt;&gt; How to use","text":"<pre><code>@ExtendWith(FixtureExtension.class)\n@Fixtures(value = { Owner.class, Pet.class }, lifecycle = Fixtures.Lifecycle.PER_METHOD)\nclass MyTest {\n    // Fixtures are loaded outside of Spring\u2019s transaction mechanism\n}\n</code></pre>"},{"location":"json_simple_fixtures/#loading-lifecycle_1","title":"&gt;&gt; Loading lifecycle","text":"<p>Optional control is given on when the fixtures are loaded with <code>Fixtures.Lifecycle</code> (<code>PER_METHOD</code> or <code>PER_CLASS</code>)   The default  is <code>PER_METHOD</code>.</p>"},{"location":"json_simple_fixtures/#purging","title":"&gt;&gt; Purging","text":"<p>Since there's no rollback or DB purging, cleanup must be managed \"by hand\" if needed</p>"},{"location":"json_simple_fixtures/#how-it-works_1","title":"&gt;&gt; How it works","text":"<ul> <li>The <code>FixtureExtension</code> is a JUnit 5 extension.  </li> <li>It hooks into the JUnit lifecycle callbacks:  </li> <li><code>beforeEach</code> \u2192 loads fixtures before each test method.  </li> <li><code>beforeAll</code> \u2192 loads fixtures once per test class.  </li> <li>No Spring transaction is involved, so the data is committed directly to the database.  </li> <li>That means:</li> <li>Data will persist across tests unless you clean it manually.  </li> <li>You can still control timing (<code>PER_METHOD</code> vs <code>PER_CLASS</code>), but not rollback.  </li> </ul> <p>\ud83d\udc49 This is why the Spring version is preferred: it leverages the built-in transaction management that Spring already provides.</p> <p> </p>"},{"location":"json_simple_fixtures/#3-common-to-both-fixture-configuration","title":"&gt; 3. Common to both: Fixture Configuration","text":"<p>Fixtures are declared in JSON and stored in:</p> <pre><code>src/test/resources/json_simple_fixtures/tests/&lt;TestClassName&gt;/&lt;EntityClass&gt;.json\n</code></pre> <p>For example:</p> <pre><code>src/test/resources/json_simple_fixtures/tests/MyIntegrationTest/Owner.json\n</code></pre> <p>Fixtures must be listed in the correct order if there are relationships:</p> <pre><code>@Fixtures({ Owner.class, Pet.class })\n</code></pre> <p> </p>"},{"location":"json_simple_fixtures/#4-comparison-between-the-two","title":"&gt; 4. Comparison between the two","text":"Feature SpringFixtureLoader JUnitFixtureLoader Managed by Spring Yes No Transaction rollback Yes No Automatic fixture cleanup Yes No Requires <code>@ExtendWith</code> No Yes Recommended for most tests Yes No (use only if needed)"},{"location":"json_simple_fixtures/#junit-fixture-loading-extension-based","title":"&gt;&gt; JUnit Fixture Loading (Extension-based)","text":"<ul> <li>The <code>FixtureExtension</code> is a JUnit 5 extension.  </li> <li>It hooks into the JUnit lifecycle callbacks:  </li> <li><code>beforeEach</code> \u2192 loads fixtures before each test method.  </li> <li><code>beforeAll</code> \u2192 loads fixtures once per test class.  </li> <li>No Spring transaction is involved, so the data is committed directly to the database.  </li> <li>That means:</li> <li>Data will persist across tests unless you clean it manually.  </li> <li>You can still control timing (<code>PER_METHOD</code> vs <code>PER_CLASS</code>), but not rollback.  </li> </ul> <p>\ud83d\udc49 This is why the Spring version is preferred: it leverages the built-in transaction management that Spring already provides.</p>"},{"location":"profiling_hibernate/","title":"SQL Profiling and Performance Diagnostics","text":"<p>This project includes two complementary profiling mechanisms that enhance visibility into SQL query behavior and ORM performance:</p> <ol> <li>Performance Profiler (Hibernate Statistics) \u2013 \"descending\": trace how many requests domain level methods have generated.</li> <li>JDBC SQL Proxy Logging \u2013 trace what domain level method generated individual SQL queries</li> </ol> <p>These tools can prove highly helpful during development and diagnostics to help identify performance bottlenecks and detect inefficient database access patterns.  </p> <p>Both mechanisms are opt-in and non-invasive.</p> <p>Why is this useful? </p> <p>Hibernate abstracts away SQL \u2013 which is great, until performance issues arise. But once they do, just enabling <code>org.hibernate.SQL</code> logs shows what SQL is executed, not who triggered it. These tools make it possible to link domain methods to actual SQL queries played against the DB. Understanding who triggers which SQL, and how often, comes in as essential for: - Detecting N+1 query problems - Profiling slow queries - Understanding ORM caching behavior - Tracing code paths that result in SQL calls</p> <p></p>"},{"location":"profiling_hibernate/#1-performance-profiler-hibernate-statistics","title":"&gt; 1. Performance Profiler (Hibernate statistics)","text":""},{"location":"profiling_hibernate/#strategy","title":"&gt;&gt; Strategy","text":"<p>Collect and log high-level Hibernate metrics like:</p> <ul> <li>Number of SQL queries executed per transaction</li> <li>Second-level cache hits/misses</li> <li>Entity load/fetch count</li> </ul> <p>This gives us a global view of ORM activity. </p>"},{"location":"profiling_hibernate/#how-it-works","title":"&gt;&gt; How it works","text":"<p>A Spring <code>@Aspect</code> is defined and wraps method execution (usually on service classes) to capture Hibernate metrics before and after method calls.</p> <p>It uses: - Hibernate <code>SessionFactory.getStatistics()</code> - Java reflection to log method/class - Execution time and query count before/after method call</p> <p>The Aspect logs these different statistics, providing method-level performance snapshots.</p>"},{"location":"profiling_hibernate/#example-output","title":"&gt;&gt; Example output","text":"<pre><code>PROFILING (Hibernate stats)--- Method CustomerQueryServiceImpl.findAllAccountByBu took 152 ms, triggered 8 SQL queries, 7 entities loaded, 5 collections loaded\n</code></pre>"},{"location":"profiling_hibernate/#enabling-and-disabling","title":"&gt;&gt; Enabling and disabling","text":"<p>In app config file (application.yaml e.g.):</p> <pre><code>profiling:\n  performance:\n    enabled: true\n    logLinePrefix: \"PROFILING (Hibernate stats)---\"\n</code></pre>"},{"location":"profiling_hibernate/#strengthslimitations","title":"&gt;&gt; Strengths/Limitations","text":"<p>\u2705 Shows cumulative ORM cost of high-level methods \u2705 Exposes cache efficiency \u2705 Helps detect query spam \u274c Doesn't show actual SQL \u274c No per-query granularity  </p> <p></p>"},{"location":"profiling_hibernate/#2-jdbc-sql-profiling-via-datasource-proxy","title":"&gt; 2. JDBC SQL Profiling via <code>datasource-proxy</code>","text":""},{"location":"profiling_hibernate/#strategy_1","title":"&gt;&gt; Strategy","text":"<p>Intercept every actual SQL statement executed at JDBC level, and log:</p> <ul> <li>The SQL</li> <li>The execution time (ms)</li> <li>The Java class, method, and line number that triggered it</li> </ul> <p>This is code-aware profiling: it bridges the gap between SQL and your business logic.</p> <p></p>"},{"location":"profiling_hibernate/#how-it-works_1","title":"&gt;&gt; How it works","text":"<p>See DataSourceProxyConfig.java.  </p> <ul> <li>A proxy wraps the <code>DataSource</code> using [datasource-proxy] (https://github.com/ttddyy/datasource-proxy)</li> <li>The proxy is registered as the primary <code>DataSource</code> (via <code>@Primary</code>)</li> <li>A custom <code>QueryExecutionListener</code> logs details after each SQL execution</li> <li>To avoid a circular dependency (Liquibase needs a DataSource early), an additional non-proxied <code>liquibaseDataSource</code> is defined</li> </ul>"},{"location":"profiling_hibernate/#required-maven-dependency","title":"&gt;&gt; Required Maven dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;net.ttddyy&lt;/groupId&gt;\n    &lt;artifactId&gt;datasource-proxy&lt;/artifactId&gt;\n    &lt;version&gt;1.9&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"profiling_hibernate/#output-example","title":"&gt;&gt; Output example","text":"<pre><code>PROFILING (dataproxy)--- SQL executed (11 ms) from [CustomerQueryServiceImpl:findAllAccountByBu:70]\nSELECT * FROM customer WHERE region = 'EU'\n</code></pre>"},{"location":"profiling_hibernate/#enabling-and-disabling_1","title":"&gt;&gt; Enabling and disabling","text":"<p>In app config file (application.yaml e.g.):</p> <pre><code>profiling:\n  sql:\n    enabled: true\n    logLinePrefix: \"PROFILING (dataproxy)---\"\n</code></pre>"},{"location":"profiling_hibernate/#strengthslimitations_1","title":"&gt;&gt; Strengths/Limitations","text":"<p>\u2705 Logs every SQL \u2705 Associates queries to the triggering code \u2705 Measures latency per query \u2705 Works across Hibernate, JPA, JdbcTemplate, etc. \u274c Cannot introspect ORM-level events (cache, flush, etc.) \u274c Log volume can be high  </p> <p></p>"},{"location":"profiling_hibernate/#3-summary-comparison","title":"&gt; 3. Summary Comparison","text":"Feature Performance Profiler (Hibernate statistics) SQL Proxy (<code>datasource-proxy</code>) SQL visibility \u274c No \u2705 Yes Execution timing \u274c No \u2705 Yes Shows triggering class/method \u274c No \u2705 Yes ORM cache, flush, lazy loading info \u2705 Yes \u274c No Tracks total query counts \u2705 Yes \u274c Not directly Easily filtered in logs \u2705 Yes (log prefix customizable) \u2705 Yes (log prefix customizable)"},{"location":"profiling_hibernate/#4-final-thoughts","title":"&gt; 4. Final thoughts","text":"<p>These two tools operate at different layers but together give a complete view of:</p> <ul> <li>What SQL was executed  </li> <li>Where in the code it was triggered  </li> <li>How long it took  </li> <li>What Hibernate was doing under the hood  </li> </ul> <p>Use them during feature development, refactoring, or performance tuning.</p>"},{"location":"template/","title":"Title","text":"<p>Introducttion</p> <p>Citation/ Emphasis</p> <p></p>"},{"location":"template/#title1","title":"&gt; Title1","text":"<p>Explanation</p>"},{"location":"template/#title11","title":"&gt;&gt; Title1.1","text":""},{"location":"template/#title111","title":"&gt;&gt;&gt; Title1.1.1","text":""},{"location":"template/#pros","title":"\u2705 Pros","text":""},{"location":"template/#-","title":"-","text":""},{"location":"template/#-_1","title":"-","text":""},{"location":"template/#cons","title":"\u274c Cons","text":""},{"location":"template/#-_2","title":"-","text":""},{"location":"template/#-_3","title":"-","text":""},{"location":"template/#title2","title":"&gt; Title2","text":""},{"location":"testing/","title":"\ud83e\uddea Spring Boot Integration Tests &amp; Database Lifecycle","text":"<p>This document explains how Spring Boot manages the database lifecycle during integration tests \u2014 specifically when the database is created, when it's dropped, and how isolation is achieved.</p> <p></p>"},{"location":"testing/#database-creation-and-dropping","title":"&gt; \ud83d\udee2\ufe0f Database Creation and Dropping","text":""},{"location":"testing/#when-is-the-database-created","title":"&gt;&gt; When is the database created?","text":"<p>When using an in-memory database like H2 and <code>spring.jpa.hibernate.ddl-auto=create-drop</code>:</p> <ul> <li>\u2705 The database schema is created once, when the application context is first started.</li> <li>This usually happens once per test class, if you're using <code>@SpringBootTest</code>.</li> <li>The same context (and DB schema) is reused across test methods in the same class.</li> <li>\u274c The database is not recreated before each test method.</li> </ul>"},{"location":"testing/#when-is-the-database-dropped","title":"&gt;&gt; When is the database dropped?","text":"<ul> <li>With <code>ddl-auto=create-drop</code>, the schema is dropped automatically when the Spring context shuts down, i.e.:</li> <li>After the test class finishes (if context was specific to that class)</li> <li>Or at the end of the full test suite (if context was reused)</li> </ul>"},{"location":"testing/#transactional-rollback-and-isolation","title":"&gt; \u267b\ufe0f Transactional Rollback and Isolation","text":""},{"location":"testing/#what-does-transactional-do","title":"&gt;&gt; What does <code>@Transactional</code> do?","text":"<p>When a test class or test method is annotated with <code>@Transactional</code>:</p> <ul> <li>Each test method runs in its own transaction</li> <li>After the test method completes, the transaction is rolled back</li> <li>This leaves the database in a clean state between tests \u2014 without recreating the schema</li> </ul>"},{"location":"testing/#example","title":"&gt;&gt; Example","text":"<pre><code>@SpringBootTest\n@Transactional\nclass MyIntegrationTest {\n\n    @Autowired\n    UserRepository userRepository;\n\n    @Test\n    void testCreateUser() {\n        userRepository.save(new User(\"Alice\"));\n        // Rolled back after the test method finishes\n    }\n}\n</code></pre>"},{"location":"testing/#controlling-db-and-context-scope","title":"&gt; \ud83d\udd0e Controlling DB and Context Scope","text":"Situation Context Reused? DB Recreated? Notes Multiple tests in same class \u2705 Yes \u274c No Same context, same schema Multiple test classes (default) \u2705 Yes \u274c No Spring optimizes by reusing context With <code>@DirtiesContext</code> \u274c No \u2705 Yes Forces full context + DB reset With <code>@Transactional</code> \u2705 Yes \u274c No Rollback used instead of full reset"},{"location":"testing/#best-practices-for-integration-tests","title":"&gt; \ud83d\udc4d Best Practices for Integration Tests","text":"<p>\u2705 Use <code>@Transactional</code> to ensure clean state without heavy DB recreation \u2705 Use <code>ddl-auto=create-drop</code> for in-memory DBs (e.g. H2) to keep schema fresh \u2705 Use <code>@DirtiesContext</code> only when you need full context isolation \u2705 Use fixture loaders (e.g. JSON or SQL) to control test data explicitly \u26a0\ufe0f Avoid <code>ddl-auto=update</code> in tests \u2014 unpredictable and risky \u26a0\ufe0f Avoid mixing stateful and stateless test strategies in the same class  </p> <p> </p>"},{"location":"testing/#common-configuration-example","title":"&gt; \u2699\ufe0f Common Configuration Example","text":"<pre><code>spring:\n  datasource:\n    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1\n    driver-class-name: org.h2.Driver\n  jpa:\n    hibernate:\n      ddl-auto: create-drop\n  sql:\n    init:\n      mode: embedded\n</code></pre>"},{"location":"testing/#summary","title":"\ud83d\udccc Summary","text":"<ul> <li>Spring Boot creates the DB once per context, usually once per test class.</li> <li>Schema is created at context startup, dropped at context shutdown.</li> <li>Use <code>@Transactional</code> for method-level isolation.</li> <li>Use <code>@DirtiesContext</code> if you need class-level isolation with fresh schema.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/","title":"DTO vs Entity Mapping Strategy \u2013 Balancing Boilerplate and Clean Design","text":"<p>True to my principle of trying to limit boilerplate code as much as possible, I\u2019ve explored several approaches to handle request mapping between incoming payloads and our domain model. As always, there\u2019s no perfect solution \u2014 only trade-offs.</p> <p>The fundamental tension is this:</p> <p>Most DTOs are nearly identical to their Entity counterparts, so duplicating field definitions and writing mapping logic feels wasteful. But exposing Entities directly is risky, especially in APIs shared with clients or frontends.</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#using-entities-directly-instead-of-dtos","title":"&gt; Using Entities Directly Instead of DTOs","text":"<p>This means making the JPA entity double as the API payload class.</p>"},{"location":"design_discussions/dto_vs_entity/#techniques","title":"&gt;&gt; Techniques","text":"<ul> <li>With Jackson:</li> <li>Use <code>@JsonIgnore</code>, <code>@JsonProperty(access = WRITE_ONLY)</code>, etc.</li> <li> <p>Use <code>@Transient</code> for fields not persisted but needed at the API level.</p> </li> <li> <p>With GSON:</p> </li> <li>Use <code>@Expose</code> to control which fields participate in (de)serialization.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#pros","title":"\u2705 Pros","text":"<ul> <li>Minimal boilerplate \u2014 no need to write or maintain separate DTOs.</li> <li>Especially useful when DTOs and Entities are 90% identical (which is very often the case).</li> <li>Works well for internal projects or quick-and-dirty endpoints.</li> <li>Automatic deserialization with almost no setup.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#cons","title":"\u274c Cons","text":"<ul> <li>Mixes concerns \u2014 Entities now serve multiple roles (persistence + API contract).</li> <li>Difficult to control what is exposed vs writable vs internal.</li> <li>Hard to evolve without breaking consumers (since persistence changes may leak into the API).</li> <li>Doesn\u2019t play well with OpenAPI generation \u2014 auto-generated schema will reflect JPA internals.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#using-records-and-projections-to-reduce-dto-boilerplate","title":"&gt; Using Records and Projections to Reduce DTO Boilerplate","text":""},{"location":"design_discussions/dto_vs_entity/#java-records-for-dtos","title":"&gt;&gt; Java Records for DTOs","text":"<p>Java records are a concise way to declare immutable data carriers \u2014 a perfect fit for simple request/response DTOs. However they are also primarily intended for read-only data and aren't ideal when you need mutable objects for writes, updates, or JPA-managed entities.</p> <pre><code>public record PetCreateDto(\n    String name,\n    LocalDate birthDate,\n    String sex,\n    String species,\n    Long ownerId,\n    String coatColor,\n    String eyeColor,\n    Double degeneracyScore\n) {}\n</code></pre>"},{"location":"design_discussions/dto_vs_entity/#pros_1","title":"\u2705 Pros","text":"<ul> <li>\u2705 Ultra-concise \u2014 no getters/setters/constructors/equals/hashCode/<code>toString</code> to write.</li> <li>\u2705 Immutability by default \u2014 great for clean functional-style code.</li> <li>\u2705 Works well with Jackson, OpenAPI generators (as long as compatible).</li> <li>\u2705 Encourages clear, flat, intention-revealing DTOs.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#cons_1","title":"\u274c Cons","text":"<ul> <li>\u274c Only really suited for Read-only</li> <li>\u274c No field-level annotations allowed inside the record declaration (e.g. <code>@NotNull</code>, <code>@JsonProperty</code>, etc.) \u2014 you have to annotate the compact constructor or fields externally.</li> <li>\u274c Not ideal for very large or deeply nested DTOs.</li> <li>\u26a0\ufe0f Not all code generators support them equally well (check OpenAPI version compatibility).</li> </ul> <p>\ud83d\udca1 Use records when DTOs are flat, simple, and immutable \u2014 they shine for request payloads and projections.</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#interface-based-projections-read-only-dtos","title":"&gt;&gt; Interface-based Projections (Read-Only DTOs)","text":"<p>Spring Data JPA supports defining projections as interfaces that only expose selected fields of an entity \u2014 without writing full DTO classes.</p> <pre><code>public interface PetSummary {\n    String getName();\n    String getSpeciesName();\n}\n</code></pre> <p>And in the repository:</p> <pre><code>List&lt;PetSummary&gt; findByOwnerId(Long ownerId);\n</code></pre> <p>Spring will automatically: - Generate a proxy that reads only the needed fields. - Avoid loading the full entity unless necessary.</p>"},{"location":"design_discussions/dto_vs_entity/#pros_2","title":"\u2705 Pros","text":"<ul> <li>\u2705 No boilerplate \u2014 just declare what you need.</li> <li>\u2705 Extremely useful for API read models (summaries, lists, etc.).</li> <li>\u2705 Encourages separation of read/write models (CQRS-like).</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#cons_2","title":"\u274c Cons","text":"<ul> <li>\u274c Read-only \u2014 can\u2019t be used for deserialization or mutation.</li> <li>\u274c No logic allowed \u2014 no methods, just getters.</li> <li>\u274c Fragile if your field names change in the entity.</li> <li>\u26a0\ufe0f Not well-suited for deep or nested object graphs.</li> </ul> <p>\ud83d\udca1 Ideal for paginated tables, read-only views, summaries, and frontend optimization.</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#summary","title":"&gt;&gt; Summary","text":"Use case Strategy \u2705 Clean, flat request DTOs Use <code>record</code> \u2705 Projection of specific fields from Entity Use <code>interface</code>-based Spring projections \u274c Mutable request payloads with validation logic Stick with standard class-based DTOs <p>Both techniques can reduce boilerplate and improve clarity, especially when paired with MapStruct or other structured mapping approaches.</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#using-separate-dtos-data-transfer-objects","title":"&gt; Using Separate DTOs (Data Transfer Objects)","text":"<p>This is the industry-favored approach (warning! this does not mean it's necessarily the best. Remember EJBs?): DTOs represent the API schema, while Entities remain persistence-only.</p>"},{"location":"design_discussions/dto_vs_entity/#pros_3","title":"\u2705 Pros","text":"<ul> <li>Clean separation of layers \u2014 API contracts are decoupled from internal model.</li> <li>Compatible with OpenAPI generator \u2014 DTOs can be auto-generated from the spec.</li> <li>Reusable in frontends \u2014 same DTO classes can power client-side types (TS/JS).</li> <li>Easier to control validation and serialization.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#cons_3","title":"\u274c Cons","text":"<ul> <li>Boilerplate mapping logic \u2014 especially when the DTO and Entity have matching fields.</li> <li>Extra layer of maintenance when the domain model changes.</li> <li>May feel like overkill for small apps or simple forms.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#what-needs-to-be-done-when-using-dtos","title":"&gt; What Needs to Be Done When Using DTOs","text":"<p>We\u2019ll need a mapping layer to translate between DTO and Entity.</p>"},{"location":"design_discussions/dto_vs_entity/#mapping-strategies","title":"&gt;&gt; Mapping Strategies","text":""},{"location":"design_discussions/dto_vs_entity/#mapstruct-recommended","title":"&gt;&gt;&gt; MapStruct (Recommended)","text":"<ul> <li>Compile-time code generation.</li> <li>Clean, fast, and easy to test.</li> <li>Supports repository injection via abstract class.</li> <li>Works great with Spring.</li> </ul> <p>Example:</p> <pre><code>@Mapper(componentModel = \"spring\")\npublic abstract class PetMapper {\n    @Autowired SpeciesRepository speciesRepo;\n    @Mapping(target = \"species\", expression = \"java(speciesRepo.findByName(dto.getSpecies()).orElseThrow())\")\n    public abstract Pet toEntity(PetCreateDto dto);\n}\n</code></pre>"},{"location":"design_discussions/dto_vs_entity/#modelmapper","title":"&gt;&gt;&gt; ModelMapper","text":"<ul> <li>Reflection-based.</li> <li>Less verbose, but slower and less safe.</li> <li>Difficult to inject services or repositories.</li> <li>Runtime config needed for enrichment logic.</li> </ul>"},{"location":"design_discussions/dto_vs_entity/#case-study-mapping-a-string-to-an-entity-species","title":"&gt;&gt; Case Study: Mapping a String to an Entity (<code>Species</code>)","text":""},{"location":"design_discussions/dto_vs_entity/#what-we-want-to-achieve","title":"&gt;&gt;&gt; What We Want to Achieve","text":"<p>Rather than forcing API consumers to send opaque database IDs like:</p> <pre><code>{\n  \"speciesId\": 345\n}\n</code></pre> <p>\u2026we'd like to let them simply send:</p> <pre><code>{\n  \"species\": \"DOG\"\n}\n</code></pre> <p>This is: - More intuitive for clients (who likely don\u2019t care about internal DB IDs) - Easier to debug and test - More readable in logs, Postman, and OpenAPI docs - More stable across environments (IDs can change, names generally don\u2019t)</p> <p>We want this <code>species</code> string (e.g. <code>\"DOG\"</code>) to be resolved internally into a <code>Species</code> JPA entity, and injected into the resulting domain object.</p>"},{"location":"design_discussions/dto_vs_entity/#strategies-to-resolve-a-string-to-an-entity","title":"&gt;&gt;&gt; Strategies to Resolve a String to an Entity","text":""},{"location":"design_discussions/dto_vs_entity/#option-1-enrich-in-the-service-layer","title":"&gt;&gt;&gt;&gt; Option 1: Enrich in the Service Layer","text":"<p>In this approach, a clear distinction is kept between:</p> <ul> <li><code>PetCreateDto</code>: the OpenAPI-generated DTO received from the client, with simple fields like <code>String species</code>, <code>Long ownerId</code>.</li> <li><code>Pet</code>: the JPA entity model, which expects full references (<code>Species</code>, <code>Owner</code>).</li> </ul> <p>A mapper (e.g. MapStruct) is used to copy the simple fields from <code>PetCreateDto</code> into a partially constructed <code>Pet</code> object, and then enrich that object inside the <code>PetService</code> before saving it. This is where the translation happens:</p> <pre><code>public Pet createPet(PetCreateDto dto) \n{\n    Pet pet = petMapper.toEntity(dto); // Maps simple fields, species still null\n\n    Species species = speciesRepository.findByNameIgnoreCase(dto.getSpecies())\n                                       .orElseThrow(\n                                        () -&gt; new IllegalArgumentException(\n                                             \"Unknown  species: \" + dto.getSpecies()));\n    pet.setSpecies(species);\n    return petRepository.save(pet);\n}\n</code></pre> <p>\u2705 Simple and explicit \u2014 each step is clear and under your control. \u2705 No Spring binding magic \u2014 avoids confusion caused by @InitBinder, custom deserializers, etc. \u2705 Easy to debug and log \u2014 you can log unresolved species names or fallback behavior. \u274c Slightly more verbose \u2014 enrichment code lives in the service layer, and may repeat across similar services if not factored out. \u274c Split logic \u2014 mapping and enrichment are separated, which can feel less cohesive than having it all in one place (e.g. in the mapper).  </p> <p>This approach works well when clarity is valued handling a bit of logic in the service is not a problem. It also makes unit testing easier by keeping repository access and enrichment explicit and injectable.</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#option-2-use-mappingexpression-in-mapstruct","title":"&gt;&gt;&gt;&gt; Option 2: Use <code>@Mapping(expression = \"...\")</code> in MapStruct","text":"<p>The enrichment logic is pushed into the mapper itself:</p> <pre><code>@Mapper(componentModel = \"spring\")\npublic abstract class PetMapper \n{\n    @Autowired SpeciesRepository speciesRepo;\n\n    @Mapping(target = \"species\", \n             expression = \"java(speciesRepo.findByNameIgnoreCase(dto.getSpecies()).orElseThrow())\")\n    public abstract Pet toEntity(PetCreateDto dto);\n}\n</code></pre> <p>\u2705 Keeps service layer ultra-minimal \u2705 All mapping logic lives in one place \u26a0\ufe0f Slightly harder to unit test \u26a0\ufe0f Can feel \"magic\" if abused</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#option-3-custom-json-deserializer","title":"&gt;&gt;&gt;&gt; Option 3: Custom JSON Deserializer","text":"<p>Attach a <code>@JsonDeserialize(using = ...)</code> to the <code>species</code> field and resolve the entity in the deserializer.</p> <pre><code>public class Pet\n{   ...\n    @JsonDeserialize(using = SpeciesDeserializer.class)\n    private Species species;\n</code></pre> <p>\u274c Doesn't play well with Spring DI (you don\u2019t get your repository injected) \u274c Adds complexity to serialization logic \u2705 Works for enum-style value mapping (not full entities)</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#option-4-spring-initbinder-with-propertyeditor","title":"&gt;&gt;&gt;&gt; Option 4: Spring <code>@InitBinder</code> with <code>PropertyEditor</code>","text":"<p>A custom editor for <code>Species</code> is registered that resolves a string into an entity:</p> <pre><code>@InitBinder\npublic void initBinder(WebDataBinder binder)\n{\n    binder.registerCustomEditor(Species.class, new SpeciesEditor(speciesRepository));\n}\n</code></pre> <p>\u26a0\ufe0f Works only for fields bound via <code>@RequestParam</code> or if the DTO directly contains a <code>Species</code> object \u274c Not triggered when DTOs use <code>String species</code> \u2705 Clean Spring idiom \u2014 but better suited to simpler types or legacy code</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#summary_1","title":"&gt;&gt;&gt; Summary","text":"<p>Using business-friendly identifiers (like <code>\"DOG\"</code> instead of <code>345</code>) improves API usability and readability. For enrichment, we found that MapStruct with repository injection offered the best balance of cleanliness, safety, and developer happiness.</p> <p></p>"},{"location":"design_discussions/dto_vs_entity/#final-approach-chosen-for-this-project","title":"&gt; Final Approach Chosen for This Project","text":"<p>After evaluating the above, the following seems like the best compromise:</p> <p>OpenAPI-generated DTOs + MapStruct abstract class</p> <p>Why?</p> <ul> <li>Keeps DTOs aligned with the OpenAPI contract (automated, client-friendly).</li> <li>Avoids writing mapping boilerplate \u2014 MapStruct does the heavy lifting.</li> <li>Injects repositories directly in the mapper for field enrichment (<code>Species</code>, <code>Owner</code>, etc.).</li> <li>All logic is centralized and testable.</li> <li>Maintains clean layering between API and persistence.</li> </ul> <pre><code>@Mapper(componentModel = \"spring\")\npublic abstract class PetMapper \n{\n    @Autowired SpeciesRepository speciesRepo;\n    @Autowired OwnerRepository ownerRepo;\n\n    @Mapping(target = \"species\", expression = \"java(speciesRepo.findByNameIgnoreCase(dto.getSpecies()).orElseThrow())\")\n    @Mapping(target = \"owner\", expression = \"java(ownerRepo.findById(dto.getOwnerId()).orElseThrow())\")\n    public abstract Pet toEntity(PetCreateDto dto);\n}\n</code></pre> <p>This gives us a pragmatic balance between developer productivity and clean architecture. One mapper, no manual setters, zero surprises.</p>"},{"location":"moxter/","title":"Introduction","text":"<p>Moxter (previously FixtureEngine) is a lightweight, configuration-oriented, Spring <code>MockMvc</code>-based utility designed to facilitate and automate JUnit test set-up.</p> <p>It provides a declarative way to describe test setup steps, aka \"fixtures\", necessary to set up the context of a JUnit test before performing the core test logic.</p> <p>Instead of scattering <code>MockMvc</code> calls and JSON boilerplate throughout the tests themselves, FixtureEngine centralizes and configures the set-up steps in YAML files, which can then be executed on demand from within the test itself. This makes tests shorter, more readable, and easier to maintain.</p> <p></p>"},{"location":"moxter/#tldr","title":"TL;DR","text":"<ul> <li>A fixture is a declarative configuration for an HTTP call executed via <code>MockMvc</code>. (the term is popular in the Python ecosystem)</li> <li>Fixtures are defined in <code>fixtures.yaml</code> files (next to your test class; see path rules below).</li> <li>Fixtures are callable from JUnit tests.</li> <li>In your JUnit tests, build the engine with: <code>FixtureEngine.forTestClass(getClass()).mockMvc(mockMvc).authentication(auth).build()</code></li> <li>Then call fixtures by name with: <code>fx.callFixture(\"create_bcs\")</code>, <code>fx.callFixtureReturnId(\"create-offer\")</code>, \u2026</li> <li>Payloads can be YAML/JSON objects, JSON strings, or <code>classpath:</code> includes.</li> <li>Responses can save variables via JsonPath: <code>save: { myId: $.id }</code> \u2192 variables can be reused in other fixtures or retrieved in tests.</li> <li>Fixtures can also be grouped and executed together just like a single fixture.</li> <li>Auth can be provided to the engine so that it is automatically attached per request and CSRF tokens auto-added on mutating verbs; no need to touch <code>SecurityContextHolder</code>.</li> </ul>"},{"location":"moxter/first_simple_example/","title":"A First Simple Example","text":"<p>This chapter demonstrates the most common workflow in Moxter: executing a basic HTTP request and capturing data from the response to use later in your test suite.</p>"},{"location":"moxter/first_simple_example/#the-yaml-definition","title":"The YAML Definition","text":"<p>Place a file named fixtures.yaml in your test resources (e.g., <code>src/test/resources/moxter/simple/</code>). This file describes the \"what\"\u2014the declarative state of your HTTP call.</p> <pre><code>fixtures:\n  - name: create_pet\n    method: POST\n    endpoint: /api/pets\n    expectedStatus: 201\n    payload:\n      firstName: \"Thomas \"\n      lastName: \"O'Malley\"\n      address: \"Alleyways and rooftops\"\n      city: \"Paris\"\n    save:\n      petId: $.id    # Captures the 'id' field from the JSON response body\n                     # (usint JSonPath syntax) so it can be used either in # another fixture, or inside the JUnit test.\n</code></pre>"},{"location":"moxter/first_simple_example/#the-java-execution","title":"The Java Execution","text":"<p>In your JUnit test, you build the engine and call the fixture by its symbolic name. Moxter handles the MockMvc execution, JSON serialization, and status assertions automatically.</p> <pre><code>@SpringBootTest\n@AutoConfigureMockMvc\nclass PetIntegrationTest {\n\n    @Autowired\n    private MockMvc mockMvc; // Injected by Spring Test context\n\n    private static Moxter mx;  // Our fixture engine\n\n    @BeforeAll\n    static void setup(@Autowired MockMvc mockMvc) {\n        // Build the engine for this test class\n        mx = Moxter.forTestClass(OwnerIntegrationTest.class)\n                .mockMvc(mockMvc)\n                .build();\n    }\n\n    @Test\n    void testShampooOnPet() {\n\n        // 1. First we'll need a pet\n        // =&gt; Execute the fixture defined in YAML\n        mx.callFixture(\"create_pet\");\n\n        // 2. Retrieve the captured variable using Moxter's typed accessors\n        Long newId = mx.varsGetLong(\"ownerId\");\n\n        assertNotNull(newId, \"The pet ID should have been captured from the response\");\n\n        // Now that we have our pet created, we can perform the actual \n        // logic intended for this test:\n\n        // Testing the shampoo:\n        ...\n\n    }\n}\n</code></pre>"},{"location":"moxter/first_simple_example/#how-it-works","title":"How it Works","text":"<p>Moxter acts as a coordination layer between your declarative YAML files and the Spring MockMvc framework.</p> <p>Discovery: The engine finds the fixtures.yaml based on your test's package name.</p> <p>Resolution: Any placeholders like {{var}} in the YAML are replaced by values currently in the engine's memory.</p> <p>Assertion: If the server returns anything other than the expectedStatus (201 in this case), the test fails immediately with a descriptive error message showing the response body.</p> <p>Persistence: The save block extracts the ID from the response and stores it in a shared map, making it available for any subsequent fixture calls or Java assertions.</p>"},{"location":"moxter/first_simple_example/#scope","title":"Scope","text":"<p>While Moxter was originally conceived as a helper for setting up test context (the \"Given\" part) which can sometimes prove quite tedious, you may have noticed that nothing stops you from using fixture-driven calls to your API to drive the core logic of the test itself, thus allowing you to orchestrate entire integration scenarios (almost) without leaving your YAML.</p>"}]}