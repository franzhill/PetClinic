package com.fhi.pet_clinic.tests.transaction;


import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.fail;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.support.TransactionTemplate;

import jakarta.persistence.EntityManager;
import lombok.extern.slf4j.Slf4j;

/**
 * Sanity check to verify that Spring's @Transactional annotation properly rolls back on RuntimeException.
 * 
 * This test helps detect subtle misconfigurations (e.g. auto-commit enabled by a proxied DataSource)
 * that can silently break rollback behavior.
 * 
 * Run with
 * $ mvn test -Dtest=TransactionRollbackTest
 */
@SpringBootTest
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)   // Required to use non-static @AfterAll with @Autowired EntityManager. Optional for JUnit 5.7+
@Slf4j
public class TransactionRollbackTest 
{
   public static final String MSG_RUNTIME_EXCEPTION = "Intentional failure to trigger rollback";
   public static final String TEST_TABLE_NAME       = "tmp_transaction_rollback_test";

   @Autowired
   private RollbackTestService rtService;

   @Autowired
   private RollbackTestRepository rtRepository;

   @Autowired
   private EntityManager em;

   /**
    * Lifecycle methods like @BeforeAll/@AfterAll aren't invoked inside a transactional proxy by default,
    * so @Transactional has no effect on them.
    * However, these methods interact with the database using update/delete queries, which require an active transaction.
    * TransactionTemplate allows us to explicitly start a transactional context, ensuring proper execution.
    */
   @Autowired
   private TransactionTemplate transactionTemplate;


   @BeforeAll
   void createTestTable() 
   {  log.debug("[TEST SETUP] Creating {}", TEST_TABLE_NAME);
      transactionTemplate.executeWithoutResult(status -> {
         var createTableSql = String.format("""
               CREATE TABLE %s (
                  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                  content VARCHAR(255)
               )
               """, TEST_TABLE_NAME);
         em.createNativeQuery(createTableSql).executeUpdate();
      });
   }


   /**
    * Delete the tmp table, just to be sure.
    * This is mostly "belt and suspenders" because we are already performing tests against a H2 DB. (dropped on each test???)
    */
   @AfterAll
   void dropTestTable() 
   {  log.debug("[TEST CLEANUP] Dropping {}", TEST_TABLE_NAME);
      transactionTemplate.executeWithoutResult(status -> {
         em.createNativeQuery("DROP TABLE IF EXISTS " + TEST_TABLE_NAME).executeUpdate();
      });
   }


   @DisplayName("A @Transactional method should be rollbacked properly if an exception arises.")
   @Test
   void shouldRollbackTransactionOnRuntimeException() 
   {
      // Given: nothing in DB
      assertThat(rtRepository.count()).isZero();

      // When: we try to insert an item in DB but an exception arises
      try 
      {   rtService.saveAndFail("Hello Rollback");
         fail("Expected a RuntimeException to have been thrown by saveAndFail()");
      } 
      catch (RuntimeException e) 
      {   // This is the exception in question.
         // (Just make sure it's really OUR exception and not some other unforeseen one)
         assertThat(e.getMessage()).isEqualTo(MSG_RUNTIME_EXCEPTION);
      }

      // Then: rollback should have occurred and nothing should have been inserted in DB
      assertThat(rtRepository.count()).isZero(); 
   }


   @DisplayName("A @Transactional method should commit if no exception is thrown.")
   @Test
   void shouldCommitTransactionOnSuccess() 
   {
      // Given
      assertThat(rtRepository.count()).isZero();

      // When
      rtService.saveWithoutFail("Hello Commit");

      // Then
      assertThat(rtRepository.count()).isEqualTo(1);
   }


}

